var canvas = document.getElementById("renderCanvas");

var startRenderLoop = function (engine, canvas) {
  engine.runRenderLoop(function () {
    if (sceneToRender && sceneToRender.activeCamera) {
      sceneToRender.render();
    }
  });
};

var engine = null;
var scene = null;
var sceneToRender = null;
var xrSessionInit = false; // Flag to track XR session initialization
var box = null;
var ignoreHitTest = false;
var inARMode = false;
var boxPlaced = false;
// Define a scaling factor
const MINIMUM_SIZE = 0.1;
const MAXIMUM_SIZE = 2;

const pointerCache = [];
let prevDiffX = -1;
let prevDiffY = -1;
let scalingFactor = 0.3;
let isGestureInProgress = false;

let clockwise = false;
let antiClockwise = false;
var isDraggingObject = false;
let lastX = null;
let targetRotation;

var createDefaultEngine = function () {
  return new BABYLON.Engine(canvas, true, {
    preserveDrawingBuffer: true,
    stencil: true,
    disableWebGL2Support: false,
  });
};
var importModel = function (scene, onModelImported) {
  BABYLON.SceneLoader.ImportMesh(
    "",
    "/",
    "AR_Precedent_V3_2Kres.glb",
    scene,
    function (newMeshes, particleSystems, skeletons, animationGroups) {
      if (newMeshes.length > 0) {
        var model = newMeshes[0]; // Assuming the imported GLB has only one mesh
        model.scaling = new BABYLON.Vector3(0.3, 0.3, 0.3); // Scale down the model
        model.position.y = 2; // Adjust the position as needed
        onModelImported(model);
      } else {
        console.error("No meshes were imported.");
      }
    }
  );
};
function attachOwnPointerDragBehavior(mesh) {
  var pointerDragBehavior = new BABYLON.PointerDragBehavior();
  pointerDragBehavior.moveAttached = false;
  pointerDragBehavior.useObjectOrientationForDragging = true;

  pointerDragBehavior.onDragStartObservable.add((event) => {
    if (isGestureInProgress) {
      return;
    }
    console.log("startDrag");
    isDraggingObject = true;
  });

  pointerDragBehavior.onDragObservable.add((event) => {
    if (isGestureInProgress) {
      return;
    }
    console.log("drag");
    isDraggingObject = true;
    pointerDragBehavior.attachedNode.position.x += event.delta.x;
    //pointerDragBehavior.attachedNode.position.y += event.delta.y;
    pointerDragBehavior.attachedNode.position.z += event.delta.z;
    //ground.isVisible = true;
  });

  pointerDragBehavior.onDragEndObservable.add((event) => {
    if (isGestureInProgress) {
      return;
    }
    console.log("endDrag");
    isDraggingObject = false;
    //ground.isVisible = false;
  });

  mesh.addBehavior(pointerDragBehavior);
}

//AR
var createScene = async function () {
  var scene = new BABYLON.Scene(engine);
  var camera = new BABYLON.ArcRotateCamera(
    "camera1",
    -Math.PI / 2,
    Math.PI / 2,
    10,
    BABYLON.Vector3.Zero(),
    scene
  );

  camera.setTarget(BABYLON.Vector3.Zero());

  camera.attachControl(canvas, true);
  var light = new BABYLON.HemisphericLight(
    "light",
    new BABYLON.Vector3(0, 1, 0),
    scene
  );
  light.intensity = 0.7;
  // createBox(scene);
  var xr = await scene.createDefaultXRExperienceAsync({
    uiOptions: {
      sessionMode: "immersive-ar",
    },
    optionalFeatures: true,
    pointerSelectionOptions: {
      enablePointerSelectionOnAllControllers: true,
    },
  });

  const fm = xr.baseExperience.featuresManager;
  const xrTest = fm.enableFeature(BABYLON.WebXRHitTest, "latest");

  const marker = BABYLON.MeshBuilder.CreateGround(
    "marker",
    { width: 1, height: 1 },
    scene
  );
  marker.material = new BABYLON.StandardMaterial("markerMat", scene);
  marker.material.diffuseColor = new BABYLON.Color3(0, 0, 1);
  marker.material.alpha = 0.1;
  marker.isVisible = false;

  xr.baseExperience.sessionManager.onXRSessionInit.add((session) => {
    xrSessionInit = true; // XR session is now initialized
    session.addEventListener("select", function () {
      if (!marker.isVisible || boxPlaced) {
        return;
      }
      if (!box) {
        // Import the model (replace this part with the new code)
        BABYLON.SceneLoader.ImportMesh(
          "",
          "/",
          "AR_Precedent_V3_2Kres.glb",
          scene,
          function (newMeshes, particleSystems, skeletons, animationGroups) {
            box = newMeshes[0]; // Assuming the imported GLB has only one mesh
            box.scaling = new BABYLON.Vector3(0.3, 0.3, 0.3); // Scale down the model
            if (box.parent) {
              console.log("The model has a parent:", box.parent.name);
            }

            if (box.rotationQuaternion) {
              box.rotationQuaternion = null;
            }

            box.rotation.y = Math.PI * 2;
            targetRotation = box.rotation.y;
            console.log(targetRotation);
            scene.registerBeforeRender(function () {
              box.rotation.y += (targetRotation - box.rotation.y) * 0.1;
            });
            attachOwnPointerDragBehavior(box);
            box.position = marker.position.clone();
            box.rotationQuaternion = marker.rotationQuaternion.clone();
            box.scaling = marker.scaling.clone();
          }
        );
      }
      // box.position = marker.position.clone();
      // box.rotationQuaternion = marker.rotationQuaternion.clone();
      // box.scaling = marker.scaling.clone();
      boxPlaced = true;
      marker.isVisible = false;
      xrTest.isEnabled = false;
      ignoreHitTest = true;
      setTimeout(() => {
        ignoreHitTest = false;
        marker.isVisible = false;
      }, 1000);

      // Define a function to handle the pinch gesture
      //   function onPinch(evt) {
      //     // Calculate the pinch distance
      //     const pinchDistance = evt.radius;

      //     // Determine the zoom direction based on the pinch distance
      //     if (pinchDistance > 0) {
      //       scalingFactor *= 1.01; // Zoom in
      //     } else {
      //       scalingFactor *= 0.99; // Zoom out
      //     }

      //     // Apply the scaling factor to the model
      //     if (box) {
      //       box.scaling = new BABYLON.Vector3(
      //         scalingFactor,
      //         scalingFactor,
      //         scalingFactor
      //       );
      //     }
      //   }
    });
  });

  xrTest.onHitTestResultObservable.add((results) => {
    if (ignoreHitTest) return;

    if (results.length) {
      if (!box) {
        marker.isVisible = true;
      }
      let hitTest = results[0];
      hitTest.transformationMatrix.decompose(
        marker.scaling,
        marker.rotationQuaternion,
        marker.position
      );
    } else {
      marker.isVisible = false;
    }
  });

  // for pinch gesture
  scene.onPointerObservable.add((pointerInfo) => {
    switch (pointerInfo.type) {
      case BABYLON.PointerEventTypes.POINTERDOWN:
        pointerCache.push(pointerInfo);
        break;
      case BABYLON.PointerEventTypes.POINTERUP:
        remove_event(pointerInfo);
        break;
      case BABYLON.PointerEventTypes.POINTERMOVE:
        pointermove_handler(pointerInfo);
        handleRotation(pointerInfo);
        break;
      default:
        break;
    }
  });
  // scene.registerBeforeRender(function () {
  //   box.rotation.y += (targetRotation - box.rotation.y) * 0.1;
  // });

  function remove_event(pointerInfo) {
    for (let i = 0; i < pointerCache.length; i++) {
      if (pointerCache[i].event.id === pointerInfo.event.id) {
        pointerCache.splice(i, 1);
        break;
      }
    }
  }

  function pointermove_handler(ev) {
    // Update the pointerCache with current event
    for (let i = 0; i < pointerCache.length; i++) {
      if (ev.event.pointerId == pointerCache[i].event.pointerId) {
        pointerCache[i] = ev;
        break;
      }
    }

    if (pointerCache.length === 2) {
      isGestureInProgress = true;

      // Getting coordinates of two pointers
      const firstPoint = {
        x: pointerCache[0].pickInfo.ray.origin.x,
        y: pointerCache[0].pickInfo.ray.origin.y,
      };
      const secondPoint = {
        x: pointerCache[1].pickInfo.ray.origin.x,
        y: pointerCache[1].pickInfo.ray.origin.y,
      };
      //handleRotation(firstPoint, secondPoint);
      // Calculate differences
      const diffX = firstPoint.x - secondPoint.x;
      const diffY = firstPoint.y - secondPoint.y;

      const currentDistance = Math.sqrt(diffX * diffX + diffY * diffY);
      const prevDistance = Math.sqrt(
        prevDiffX * prevDiffX + prevDiffY * prevDiffY
      );

      // Check if fingers are moving apart or closer
      if (currentDistance > prevDistance) {
        scalingFactor += 0.02;
      } else if (currentDistance < prevDistance) {
        scalingFactor -= 0.02;
      }

      // Clamp scalingFactor between MAXIMUM_SIZE and MINIMUM_SIZE
      scalingFactor = Math.max(
        Math.min(scalingFactor, MAXIMUM_SIZE),
        MINIMUM_SIZE
      );

      // Apply scaling
      box.scaling = new BABYLON.Vector3(
        scalingFactor,
        scalingFactor,
        scalingFactor
      );

      // Store current differences for the next event
      prevDiffX = diffX;
      prevDiffY = diffY;

      isDraggingObject = false;
    } else {
      isGestureInProgress = false;
    }
  }
  const ROTATION_SPEED = 0.08;

  function handleRotation(pointerInfo) {
    if (isDraggingObject || pointerCache.length == 2) {
      return;
    }
    const x = pointerInfo.event.screenX;
    const threshold = 5;

    if (lastX === null) {
      lastX = x;
      return;
    }

    const delta = x - lastX;

    if (delta > threshold) {
      targetRotation += ROTATION_SPEED;
    } else if (delta < -threshold) {
      targetRotation -= ROTATION_SPEED;
    }

    lastX = x;
  }

  return scene;
};
engine = createDefaultEngine();
if (!engine) throw "engine should not be null.";

createScene().then(function (newScene) {
  scene = newScene;
  sceneToRender = scene;
  startRenderLoop(engine, canvas);
});
box = importModel(scene);

// Resize
window.addEventListener("resize", function () {
  engine.resize();
});
